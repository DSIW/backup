#!/usr/bin/env ruby
# encoding: utf-8

require "colorize"
require "optparse"
require "json"

require_relative "backup_lib"
include BackupLib

begin
  CONFIG = JSON.parse(File.read("#{HOME}/.backuprc"), symbolize_names: true)
rescue Exception => e
  puts "Config parsing error:"
  puts e.message.red
  puts "Using default configuration"
  puts
  CONFIG = {
    intervals: %w[daily weekly monthly yearly]
  }
end

CCOLLECT_LOGWRAPPER = "#{HOME}/sys/bin/ccollect_logwrapper"

# Interval.source = Interval::SOURCES::BACKUP_DIR

module Utils
  def self.colorize(string, color)
    if string.respond_to? color
      string.send(color)
    else
      string
    end
  end

  def self.pluralize(count, singular, plural, options = {})
    suffix = count.abs == 1 ? singular : plural
    [count, suffix].join(' ')
  end

  # with continous output
  def self.system(command)
    IO.popen command do |descriptor|
      puts descriptor.readline until descriptor.eof?
    end
  end

  def self.exit_with_error(message)
    STDERR.puts Utils.colorize(message, :red)
    exit 1
  end

  def self.parse_options
    options = {}
    OptionParser.new do |opts|
      opts.banner = "Usage: []"

      opts.on("-u", "--update-status", "Update ~/.lastbackups") do |v|
        options[:update_status] = v
      end

      opts.on("-n", "--dry-run", "Dry run") do |v|
        options[:dry_run] = v
      end

      options[:intervals] = CONFIG[:intervals]
      opts.on("--only #{SETTINGS_BY_INTERVAL.keys.join(',')}", Array, "Only update specified intervals") do |v|
        options[:intervals] = v
      end

      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
    end.parse!
    options
  end

  def self.root?
    `id -u`.chomp == "0"
  end

  def self.mounted_backup_dir?
    File.exist?(BACKUP_DIR) && !Dir.glob("#{BACKUP_DIR}/*/").empty?
  end
end

OPTIONS = Utils.parse_options

# Do backup
unless OPTIONS[:update_status]
  # Print status
  Interval.all.each { |interval| puts IntervalPresenter.new(interval).message }

  old_intervals = Interval.olds

  puts
  puts Utils.colorize("Yeah, nothing to backup!", :green) if old_intervals.empty?

  old_intervals.each do |interval|
    puts "#{interval.name.capitalize} backup started..."
    unless OPTIONS[:dry_run]
      Utils.exit_with_error "Please run this as root." unless Utils.root?
      Utils.exit_with_error "Backup directory is not mounted." unless Utils.mounted_backup_dir?
      Utils.system("#{CCOLLECT_LOGWRAPPER} #{interval.name} #{SOURCE}")
    end
  end

  puts
  puts "Please don't forget to unmount."
end

ConfigFile.new.write(Interval.all) unless OPTIONS[:dry_run]
# Update sublet
`subtler -su lastbackups` rescue nil
